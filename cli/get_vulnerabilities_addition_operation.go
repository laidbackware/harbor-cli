// Code generated by go-swagger; DO NOT EDIT.

package cli

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"

	"github.com/laidbackware/harbor-cli/client/artifact"

	"github.com/go-openapi/swag"
	"github.com/spf13/cobra"
)

// makeOperationArtifactGetVulnerabilitiesAdditionCmd returns a cmd to handle operation getVulnerabilitiesAddition
func makeOperationArtifactGetVulnerabilitiesAdditionCmd() (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use:   "getVulnerabilitiesAddition",
		Short: `Get the vulnerabilities addition of the artifact specified by the reference under the project and repository.`,
		RunE:  runOperationArtifactGetVulnerabilitiesAddition,
	}

	if err := registerOperationArtifactGetVulnerabilitiesAdditionParamFlags(cmd); err != nil {
		return nil, err
	}

	return cmd, nil
}

// runOperationArtifactGetVulnerabilitiesAddition uses cmd flags to call endpoint api
func runOperationArtifactGetVulnerabilitiesAddition(cmd *cobra.Command, args []string) error {
	appCli, err := makeClient(cmd, args)
	if err != nil {
		return err
	}
	// retrieve flag values from cmd and fill params
	params := artifact.NewGetVulnerabilitiesAdditionParams()
	if err, _ := retrieveOperationArtifactGetVulnerabilitiesAdditionXAcceptVulnerabilitiesFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationArtifactGetVulnerabilitiesAdditionXRequestIDFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationArtifactGetVulnerabilitiesAdditionProjectNameFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationArtifactGetVulnerabilitiesAdditionReferenceFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationArtifactGetVulnerabilitiesAdditionRepositoryNameFlag(params, "", cmd); err != nil {
		return err
	}
	if dryRun {

		logDebugf("dry-run flag specified. Skip sending request.")
		return nil
	}
	// make request and then print result
	msgStr, err := parseOperationArtifactGetVulnerabilitiesAdditionResult(appCli.Artifact.GetVulnerabilitiesAddition(params, nil))
	if err != nil {
		return err
	}
	if !debug {

		fmt.Println(msgStr)
	}
	return nil
}

// registerOperationArtifactGetVulnerabilitiesAdditionParamFlags registers all flags needed to fill params
func registerOperationArtifactGetVulnerabilitiesAdditionParamFlags(cmd *cobra.Command) error {
	if err := registerOperationArtifactGetVulnerabilitiesAdditionXAcceptVulnerabilitiesParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationArtifactGetVulnerabilitiesAdditionXRequestIDParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationArtifactGetVulnerabilitiesAdditionProjectNameParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationArtifactGetVulnerabilitiesAdditionReferenceParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationArtifactGetVulnerabilitiesAdditionRepositoryNameParamFlags("", cmd); err != nil {
		return err
	}
	return nil
}

func registerOperationArtifactGetVulnerabilitiesAdditionXAcceptVulnerabilitiesParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	xAcceptVulnerabilitiesDescription := `A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it.
Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'`

	var xAcceptVulnerabilitiesFlagName string
	if cmdPrefix == "" {
		xAcceptVulnerabilitiesFlagName = "X-Accept-Vulnerabilities"
	} else {
		xAcceptVulnerabilitiesFlagName = fmt.Sprintf("%v.X-Accept-Vulnerabilities", cmdPrefix)
	}

	var xAcceptVulnerabilitiesFlagDefault string = "application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0"

	_ = cmd.PersistentFlags().String(xAcceptVulnerabilitiesFlagName, xAcceptVulnerabilitiesFlagDefault, xAcceptVulnerabilitiesDescription)

	return nil
}
func registerOperationArtifactGetVulnerabilitiesAdditionXRequestIDParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	xRequestIdDescription := `An unique ID for the request`

	var xRequestIdFlagName string
	if cmdPrefix == "" {
		xRequestIdFlagName = "X-Request-Id"
	} else {
		xRequestIdFlagName = fmt.Sprintf("%v.X-Request-Id", cmdPrefix)
	}

	var xRequestIdFlagDefault string

	_ = cmd.PersistentFlags().String(xRequestIdFlagName, xRequestIdFlagDefault, xRequestIdDescription)

	return nil
}
func registerOperationArtifactGetVulnerabilitiesAdditionProjectNameParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	projectNameDescription := `Required. The name of the project`

	var projectNameFlagName string
	if cmdPrefix == "" {
		projectNameFlagName = "project_name"
	} else {
		projectNameFlagName = fmt.Sprintf("%v.project_name", cmdPrefix)
	}

	var projectNameFlagDefault string

	_ = cmd.PersistentFlags().String(projectNameFlagName, projectNameFlagDefault, projectNameDescription)

	return nil
}
func registerOperationArtifactGetVulnerabilitiesAdditionReferenceParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	referenceDescription := `Required. The reference of the artifact, can be digest or tag`

	var referenceFlagName string
	if cmdPrefix == "" {
		referenceFlagName = "reference"
	} else {
		referenceFlagName = fmt.Sprintf("%v.reference", cmdPrefix)
	}

	var referenceFlagDefault string

	_ = cmd.PersistentFlags().String(referenceFlagName, referenceFlagDefault, referenceDescription)

	return nil
}
func registerOperationArtifactGetVulnerabilitiesAdditionRepositoryNameParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	repositoryNameDescription := `Required. The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb`

	var repositoryNameFlagName string
	if cmdPrefix == "" {
		repositoryNameFlagName = "repository_name"
	} else {
		repositoryNameFlagName = fmt.Sprintf("%v.repository_name", cmdPrefix)
	}

	var repositoryNameFlagDefault string

	_ = cmd.PersistentFlags().String(repositoryNameFlagName, repositoryNameFlagDefault, repositoryNameDescription)

	return nil
}

func retrieveOperationArtifactGetVulnerabilitiesAdditionXAcceptVulnerabilitiesFlag(m *artifact.GetVulnerabilitiesAdditionParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("X-Accept-Vulnerabilities") {

		var xAcceptVulnerabilitiesFlagName string
		if cmdPrefix == "" {
			xAcceptVulnerabilitiesFlagName = "X-Accept-Vulnerabilities"
		} else {
			xAcceptVulnerabilitiesFlagName = fmt.Sprintf("%v.X-Accept-Vulnerabilities", cmdPrefix)
		}

		xAcceptVulnerabilitiesFlagValue, err := cmd.Flags().GetString(xAcceptVulnerabilitiesFlagName)
		if err != nil {
			return err, false
		}
		m.XAcceptVulnerabilities = &xAcceptVulnerabilitiesFlagValue

	}
	return nil, retAdded
}
func retrieveOperationArtifactGetVulnerabilitiesAdditionXRequestIDFlag(m *artifact.GetVulnerabilitiesAdditionParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("X-Request-Id") {

		var xRequestIdFlagName string
		if cmdPrefix == "" {
			xRequestIdFlagName = "X-Request-Id"
		} else {
			xRequestIdFlagName = fmt.Sprintf("%v.X-Request-Id", cmdPrefix)
		}

		xRequestIdFlagValue, err := cmd.Flags().GetString(xRequestIdFlagName)
		if err != nil {
			return err, false
		}
		m.XRequestID = &xRequestIdFlagValue

	}
	return nil, retAdded
}
func retrieveOperationArtifactGetVulnerabilitiesAdditionProjectNameFlag(m *artifact.GetVulnerabilitiesAdditionParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("project_name") {

		var projectNameFlagName string
		if cmdPrefix == "" {
			projectNameFlagName = "project_name"
		} else {
			projectNameFlagName = fmt.Sprintf("%v.project_name", cmdPrefix)
		}

		projectNameFlagValue, err := cmd.Flags().GetString(projectNameFlagName)
		if err != nil {
			return err, false
		}
		m.ProjectName = projectNameFlagValue

	}
	return nil, retAdded
}
func retrieveOperationArtifactGetVulnerabilitiesAdditionReferenceFlag(m *artifact.GetVulnerabilitiesAdditionParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("reference") {

		var referenceFlagName string
		if cmdPrefix == "" {
			referenceFlagName = "reference"
		} else {
			referenceFlagName = fmt.Sprintf("%v.reference", cmdPrefix)
		}

		referenceFlagValue, err := cmd.Flags().GetString(referenceFlagName)
		if err != nil {
			return err, false
		}
		m.Reference = referenceFlagValue

	}
	return nil, retAdded
}
func retrieveOperationArtifactGetVulnerabilitiesAdditionRepositoryNameFlag(m *artifact.GetVulnerabilitiesAdditionParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("repository_name") {

		var repositoryNameFlagName string
		if cmdPrefix == "" {
			repositoryNameFlagName = "repository_name"
		} else {
			repositoryNameFlagName = fmt.Sprintf("%v.repository_name", cmdPrefix)
		}

		repositoryNameFlagValue, err := cmd.Flags().GetString(repositoryNameFlagName)
		if err != nil {
			return err, false
		}
		m.RepositoryName = repositoryNameFlagValue

	}
	return nil, retAdded
}

// parseOperationArtifactGetVulnerabilitiesAdditionResult parses request result and return the string content
func parseOperationArtifactGetVulnerabilitiesAdditionResult(resp0 *artifact.GetVulnerabilitiesAdditionOK, respErr error) (string, error) {
	if respErr != nil {

		var iResp0 interface{} = respErr
		resp0, ok := iResp0.(*artifact.GetVulnerabilitiesAdditionOK)
		if ok {
			if !swag.IsZero(resp0) && !swag.IsZero(resp0.Payload) {
				msgStr, err := json.Marshal(resp0.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp1 interface{} = respErr
		resp1, ok := iResp1.(*artifact.GetVulnerabilitiesAdditionBadRequest)
		if ok {
			if !swag.IsZero(resp1) && !swag.IsZero(resp1.Payload) {
				msgStr, err := json.Marshal(resp1.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp2 interface{} = respErr
		resp2, ok := iResp2.(*artifact.GetVulnerabilitiesAdditionUnauthorized)
		if ok {
			if !swag.IsZero(resp2) && !swag.IsZero(resp2.Payload) {
				msgStr, err := json.Marshal(resp2.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp3 interface{} = respErr
		resp3, ok := iResp3.(*artifact.GetVulnerabilitiesAdditionForbidden)
		if ok {
			if !swag.IsZero(resp3) && !swag.IsZero(resp3.Payload) {
				msgStr, err := json.Marshal(resp3.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp4 interface{} = respErr
		resp4, ok := iResp4.(*artifact.GetVulnerabilitiesAdditionNotFound)
		if ok {
			if !swag.IsZero(resp4) && !swag.IsZero(resp4.Payload) {
				msgStr, err := json.Marshal(resp4.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp5 interface{} = respErr
		resp5, ok := iResp5.(*artifact.GetVulnerabilitiesAdditionInternalServerError)
		if ok {
			if !swag.IsZero(resp5) && !swag.IsZero(resp5.Payload) {
				msgStr, err := json.Marshal(resp5.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		return "", respErr
	}

	if !swag.IsZero(resp0) && !swag.IsZero(resp0.Payload) {
		msgStr := fmt.Sprintf("%v", resp0.Payload)
		return string(msgStr), nil
	}

	return "", nil
}
