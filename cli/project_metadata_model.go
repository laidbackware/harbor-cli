// Code generated by go-swagger; DO NOT EDIT.

package cli

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/laidbackware/harbor-cli/models"
	"github.com/spf13/cobra"
)

// Schema cli for ProjectMetadata

// register flags to command
func registerModelProjectMetadataFlags(depth int, cmdPrefix string, cmd *cobra.Command) error {

	if err := registerProjectMetadataAutoScan(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerProjectMetadataEnableContentTrust(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerProjectMetadataEnableContentTrustCosign(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerProjectMetadataPreventVul(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerProjectMetadataPublic(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerProjectMetadataRetentionID(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerProjectMetadataReuseSysCveAllowlist(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerProjectMetadataSeverity(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	return nil
}

func registerProjectMetadataAutoScan(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	autoScanDescription := `Whether scan images automatically when pushing. The valid values are 'true', 'false'.`

	var autoScanFlagName string
	if cmdPrefix == "" {
		autoScanFlagName = "auto_scan"
	} else {
		autoScanFlagName = fmt.Sprintf("%v.auto_scan", cmdPrefix)
	}

	var autoScanFlagDefault string

	_ = cmd.PersistentFlags().String(autoScanFlagName, autoScanFlagDefault, autoScanDescription)

	return nil
}

func registerProjectMetadataEnableContentTrust(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	enableContentTrustDescription := `Whether content trust is enabled or not. If it is enabled, user cant pull unsigned images from this project. The valid values are 'true', 'false'.`

	var enableContentTrustFlagName string
	if cmdPrefix == "" {
		enableContentTrustFlagName = "enable_content_trust"
	} else {
		enableContentTrustFlagName = fmt.Sprintf("%v.enable_content_trust", cmdPrefix)
	}

	var enableContentTrustFlagDefault string

	_ = cmd.PersistentFlags().String(enableContentTrustFlagName, enableContentTrustFlagDefault, enableContentTrustDescription)

	return nil
}

func registerProjectMetadataEnableContentTrustCosign(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	enableContentTrustCosignDescription := `Whether cosign content trust is enabled or not. If it is enabled, user cant pull images without cosign signature from this project. The valid values are 'true', 'false'.`

	var enableContentTrustCosignFlagName string
	if cmdPrefix == "" {
		enableContentTrustCosignFlagName = "enable_content_trust_cosign"
	} else {
		enableContentTrustCosignFlagName = fmt.Sprintf("%v.enable_content_trust_cosign", cmdPrefix)
	}

	var enableContentTrustCosignFlagDefault string

	_ = cmd.PersistentFlags().String(enableContentTrustCosignFlagName, enableContentTrustCosignFlagDefault, enableContentTrustCosignDescription)

	return nil
}

func registerProjectMetadataPreventVul(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	preventVulDescription := `Whether prevent the vulnerable images from running. The valid values are 'true', 'false'.`

	var preventVulFlagName string
	if cmdPrefix == "" {
		preventVulFlagName = "prevent_vul"
	} else {
		preventVulFlagName = fmt.Sprintf("%v.prevent_vul", cmdPrefix)
	}

	var preventVulFlagDefault string

	_ = cmd.PersistentFlags().String(preventVulFlagName, preventVulFlagDefault, preventVulDescription)

	return nil
}

func registerProjectMetadataPublic(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	publicDescription := `The public status of the project. The valid values are 'true', 'false'.`

	var publicFlagName string
	if cmdPrefix == "" {
		publicFlagName = "public"
	} else {
		publicFlagName = fmt.Sprintf("%v.public", cmdPrefix)
	}

	var publicFlagDefault string

	_ = cmd.PersistentFlags().String(publicFlagName, publicFlagDefault, publicDescription)

	return nil
}

func registerProjectMetadataRetentionID(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	retentionIdDescription := `The ID of the tag retention policy for the project`

	var retentionIdFlagName string
	if cmdPrefix == "" {
		retentionIdFlagName = "retention_id"
	} else {
		retentionIdFlagName = fmt.Sprintf("%v.retention_id", cmdPrefix)
	}

	var retentionIdFlagDefault string

	_ = cmd.PersistentFlags().String(retentionIdFlagName, retentionIdFlagDefault, retentionIdDescription)

	return nil
}

func registerProjectMetadataReuseSysCveAllowlist(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	reuseSysCveAllowlistDescription := `Whether this project reuse the system level CVE allowlist as the allowlist of its own.  The valid values are 'true', 'false'. If it is set to 'true' the actual allowlist associate with this project, if any, will be ignored.'`

	var reuseSysCveAllowlistFlagName string
	if cmdPrefix == "" {
		reuseSysCveAllowlistFlagName = "reuse_sys_cve_allowlist"
	} else {
		reuseSysCveAllowlistFlagName = fmt.Sprintf("%v.reuse_sys_cve_allowlist", cmdPrefix)
	}

	var reuseSysCveAllowlistFlagDefault string

	_ = cmd.PersistentFlags().String(reuseSysCveAllowlistFlagName, reuseSysCveAllowlistFlagDefault, reuseSysCveAllowlistDescription)

	return nil
}

func registerProjectMetadataSeverity(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	severityDescription := `If the vulnerability is high than severity defined here, the images cant be pulled. The valid values are 'none', 'low', 'medium', 'high', 'critical'.`

	var severityFlagName string
	if cmdPrefix == "" {
		severityFlagName = "severity"
	} else {
		severityFlagName = fmt.Sprintf("%v.severity", cmdPrefix)
	}

	var severityFlagDefault string

	_ = cmd.PersistentFlags().String(severityFlagName, severityFlagDefault, severityDescription)

	return nil
}

// retrieve flags from commands, and set value in model. Return true if any flag is passed by user to fill model field.
func retrieveModelProjectMetadataFlags(depth int, m *models.ProjectMetadata, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false

	err, autoScanAdded := retrieveProjectMetadataAutoScanFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || autoScanAdded

	err, enableContentTrustAdded := retrieveProjectMetadataEnableContentTrustFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || enableContentTrustAdded

	err, enableContentTrustCosignAdded := retrieveProjectMetadataEnableContentTrustCosignFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || enableContentTrustCosignAdded

	err, preventVulAdded := retrieveProjectMetadataPreventVulFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || preventVulAdded

	err, publicAdded := retrieveProjectMetadataPublicFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || publicAdded

	err, retentionIdAdded := retrieveProjectMetadataRetentionIDFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || retentionIdAdded

	err, reuseSysCveAllowlistAdded := retrieveProjectMetadataReuseSysCveAllowlistFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || reuseSysCveAllowlistAdded

	err, severityAdded := retrieveProjectMetadataSeverityFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || severityAdded

	return nil, retAdded
}

func retrieveProjectMetadataAutoScanFlags(depth int, m *models.ProjectMetadata, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	autoScanFlagName := fmt.Sprintf("%v.auto_scan", cmdPrefix)
	if cmd.Flags().Changed(autoScanFlagName) {

		var autoScanFlagName string
		if cmdPrefix == "" {
			autoScanFlagName = "auto_scan"
		} else {
			autoScanFlagName = fmt.Sprintf("%v.auto_scan", cmdPrefix)
		}

		autoScanFlagValue, err := cmd.Flags().GetString(autoScanFlagName)
		if err != nil {
			return err, false
		}
		m.AutoScan = &autoScanFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveProjectMetadataEnableContentTrustFlags(depth int, m *models.ProjectMetadata, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	enableContentTrustFlagName := fmt.Sprintf("%v.enable_content_trust", cmdPrefix)
	if cmd.Flags().Changed(enableContentTrustFlagName) {

		var enableContentTrustFlagName string
		if cmdPrefix == "" {
			enableContentTrustFlagName = "enable_content_trust"
		} else {
			enableContentTrustFlagName = fmt.Sprintf("%v.enable_content_trust", cmdPrefix)
		}

		enableContentTrustFlagValue, err := cmd.Flags().GetString(enableContentTrustFlagName)
		if err != nil {
			return err, false
		}
		m.EnableContentTrust = &enableContentTrustFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveProjectMetadataEnableContentTrustCosignFlags(depth int, m *models.ProjectMetadata, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	enableContentTrustCosignFlagName := fmt.Sprintf("%v.enable_content_trust_cosign", cmdPrefix)
	if cmd.Flags().Changed(enableContentTrustCosignFlagName) {

		var enableContentTrustCosignFlagName string
		if cmdPrefix == "" {
			enableContentTrustCosignFlagName = "enable_content_trust_cosign"
		} else {
			enableContentTrustCosignFlagName = fmt.Sprintf("%v.enable_content_trust_cosign", cmdPrefix)
		}

		enableContentTrustCosignFlagValue, err := cmd.Flags().GetString(enableContentTrustCosignFlagName)
		if err != nil {
			return err, false
		}
		m.EnableContentTrustCosign = &enableContentTrustCosignFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveProjectMetadataPreventVulFlags(depth int, m *models.ProjectMetadata, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	preventVulFlagName := fmt.Sprintf("%v.prevent_vul", cmdPrefix)
	if cmd.Flags().Changed(preventVulFlagName) {

		var preventVulFlagName string
		if cmdPrefix == "" {
			preventVulFlagName = "prevent_vul"
		} else {
			preventVulFlagName = fmt.Sprintf("%v.prevent_vul", cmdPrefix)
		}

		preventVulFlagValue, err := cmd.Flags().GetString(preventVulFlagName)
		if err != nil {
			return err, false
		}
		m.PreventVul = &preventVulFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveProjectMetadataPublicFlags(depth int, m *models.ProjectMetadata, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	publicFlagName := fmt.Sprintf("%v.public", cmdPrefix)
	if cmd.Flags().Changed(publicFlagName) {

		var publicFlagName string
		if cmdPrefix == "" {
			publicFlagName = "public"
		} else {
			publicFlagName = fmt.Sprintf("%v.public", cmdPrefix)
		}

		publicFlagValue, err := cmd.Flags().GetString(publicFlagName)
		if err != nil {
			return err, false
		}
		m.Public = publicFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveProjectMetadataRetentionIDFlags(depth int, m *models.ProjectMetadata, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	retentionIdFlagName := fmt.Sprintf("%v.retention_id", cmdPrefix)
	if cmd.Flags().Changed(retentionIdFlagName) {

		var retentionIdFlagName string
		if cmdPrefix == "" {
			retentionIdFlagName = "retention_id"
		} else {
			retentionIdFlagName = fmt.Sprintf("%v.retention_id", cmdPrefix)
		}

		retentionIdFlagValue, err := cmd.Flags().GetString(retentionIdFlagName)
		if err != nil {
			return err, false
		}
		m.RetentionID = &retentionIdFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveProjectMetadataReuseSysCveAllowlistFlags(depth int, m *models.ProjectMetadata, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	reuseSysCveAllowlistFlagName := fmt.Sprintf("%v.reuse_sys_cve_allowlist", cmdPrefix)
	if cmd.Flags().Changed(reuseSysCveAllowlistFlagName) {

		var reuseSysCveAllowlistFlagName string
		if cmdPrefix == "" {
			reuseSysCveAllowlistFlagName = "reuse_sys_cve_allowlist"
		} else {
			reuseSysCveAllowlistFlagName = fmt.Sprintf("%v.reuse_sys_cve_allowlist", cmdPrefix)
		}

		reuseSysCveAllowlistFlagValue, err := cmd.Flags().GetString(reuseSysCveAllowlistFlagName)
		if err != nil {
			return err, false
		}
		m.ReuseSysCveAllowlist = &reuseSysCveAllowlistFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveProjectMetadataSeverityFlags(depth int, m *models.ProjectMetadata, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	severityFlagName := fmt.Sprintf("%v.severity", cmdPrefix)
	if cmd.Flags().Changed(severityFlagName) {

		var severityFlagName string
		if cmdPrefix == "" {
			severityFlagName = "severity"
		} else {
			severityFlagName = fmt.Sprintf("%v.severity", cmdPrefix)
		}

		severityFlagValue, err := cmd.Flags().GetString(severityFlagName)
		if err != nil {
			return err, false
		}
		m.Severity = &severityFlagValue

		retAdded = true
	}

	return nil, retAdded
}
